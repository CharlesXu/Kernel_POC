/*
 * Samsung G3D legacy kernel driver
 *
 * Copyright (c) 2008 Samsung Electronics
 * 	Initial driver.
 *
 * Copyright 2011 Tomasz Figa <tomasz.figa at gmail.com>
 *	Code cleanup and fixes.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#define DEBUG

#include <linux/init.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/types.h>
#include <linux/timer.h>
#include <linux/kernel.h>
#include <linux/pci.h>
#include <linux/sched.h>
#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/platform_device.h>
#include <linux/interrupt.h>
#include <linux/clk.h>
#include <linux/delay.h>
#include <linux/uaccess.h>
#include <linux/errno.h>
#include <linux/mm.h>
#include <linux/tty.h>
#include <linux/io.h>
#include <linux/irq.h>
#include <linux/miscdevice.h>
#include <linux/mman.h>
#include <linux/unistd.h>
#include <linux/version.h>
#include <linux/memory.h>
#include <linux/dma-mapping.h>
#include <linux/list.h>
#include <linux/pm_runtime.h>

#include <asm/cacheflush.h>

/*
 * Various definitions
 */
#define G3D_CHUNK_SIZE 			(SZ_2M)
#define G3D_UI_CHUNK_NUM		(3)
#define G3D_AUTOSUSPEND_DELAY		(HZ/4)

#define FGGB_PIPESTATE			(0x00)
#define FGGB_RST				(0x08)
#define FGGB_VERSION			(0x10)
#define FGGB_INTPENDING			(0x40)
#define FGGB_INTMASK			(0x44)
#define FGGB_PIPEMASK			(0x48)

#define G3D_IOCTL_MAGIC			'S'
#define S3C_3D_WAIT_FOR_FLUSH		_IO(G3D_IOCTL_MAGIC, 100)
#define S3C_3D_GET_CONFIG 		_IO(G3D_IOCTL_MAGIC, 101)
#define S3C_3D_MEM_ALLOC		_IOWR(G3D_IOCTL_MAGIC, 310, struct g3d_mem_blk)
#define S3C_3D_MEM_FREE			_IOWR(G3D_IOCTL_MAGIC, 311, struct g3d_mem_blk)
#define S3C_3D_SFR_LOCK			_IO(G3D_IOCTL_MAGIC, 312)
#define S3C_3D_SFR_UNLOCK		_IO(G3D_IOCTL_MAGIC, 313)
#define S3C_3D_MEM_ALLOC_SHARE		_IOWR(G3D_IOCTL_MAGIC, 314, struct g3d_mem_blk)
#define S3C_3D_MEM_SHARE_FREE		_IOWR(G3D_IOCTL_MAGIC, 315, struct g3d_mem_blk)
#define S3C_3D_CACHE_INVALID		_IOWR(G3D_IOCTL_MAGIC, 316, struct g3d_mem_blk)
#define S3C_3D_CACHE_CLEAN		_IOWR(G3D_IOCTL_MAGIC, 317, struct g3d_mem_blk)
#define S3C_3D_CACHE_CLEAN_INVALID	_IOWR(G3D_IOCTL_MAGIC, 318, struct g3d_mem_blk)
#define S3C_3D_POWER_INIT 		_IOWR('S', 321, struct g3d_power)
#define S3C_3D_CRITICAL_SECTION  	_IOWR('S', 322, struct g3d_power)
#define S3C_3D_MAP_FIMG_SFR_ADDR	_IOWR(G3D_IOCTL_MAGIC, 324, struct g3d_mem_blk)
#define S3C_3D_UNMAP_FIMG_SFR_ADDR	_IOWR(G3D_IOCTL_MAGIC, 325, struct g3d_mem_blk)

/*
 * Data structures
 */
struct g3d_context;

struct g3d_power {
	int	request;
	int	status;
	int	reserved;
};

struct g3d_config {
	u32	sfr_base;
	u32	sfr_size;
	int	single_pipeline;
	int	dma_available;
	u32	dma_base;
	u32	dma_size;
};

struct g3d_mem_blk {
	int		size;
	void __user 	*virt;
	u32		phys;
};

struct g3d_alloc_info {
	struct g3d_context	*owner;
	u32	 		chunks;
	struct list_head	list;
};

struct g3d_chunk {
	struct g3d_mem_blk	mem;
	struct g3d_context	*owner;
};

struct g3d_drvdata {
	void __iomem		*base;

	struct mutex		ctl_lock;
	struct mutex		mem_lock;
	struct mutex		hw_lock;
	struct g3d_context	*hw_owner;
	wait_queue_head_t	waitq;

	int			irq;
	struct resource 	*mem;
	struct resource		*gmem;
	struct clk		*clock;
	struct device		*dev;
	struct miscdevice	mdev;

	struct g3d_chunk	*chunks;
	unsigned int		chunk_num;
	struct list_head	alloc_list;
	u32 			free_bitmap;
	wait_queue_head_t	mem_wq;
};

struct g3d_context {
	struct g3d_drvdata	*data;
	struct file		*file;
	int			power_requested;
	unsigned long		mmap_addr;
};

/*
 * Hardware access helpers
 */
static inline void g3d_write(struct g3d_drvdata *d, uint32_t b, uint32_t r)
{
	writel(b, d->base + r);
}

static inline uint32_t g3d_read(struct g3d_drvdata *d, uint32_t r)
{
	return readl(d->base + r);
}

static void g3d_soft_reset(struct g3d_drvdata *g3d)
{
	g3d_write(g3d, 1, FGGB_RST);
	udelay(1);
	g3d_write(g3d, 0, FGGB_RST);
}

/*
 * Interrupt handler
 */
static irqreturn_t g3d_isr(int irq, void *dev_id)
{
	struct g3d_drvdata *g3d = dev_id;

	g3d_write(g3d, 0, FGGB_INTPENDING);

	wake_up(&g3d->waitq);

	return IRQ_HANDLED;
}

/*
 * Graphics memory allocator
 */
#ifdef DEBUG
static void g3d_print_alloc_info(struct g3d_drvdata *g3d)
{
	struct g3d_alloc_info *i;

	dev_dbg(g3d->dev, "Memory allocator info:\n");

	if (list_empty(&g3d->alloc_list)) {
		dev_dbg(g3d->dev, "Empty\n");
		return;
	}

	list_for_each_entry(i, &g3d->alloc_list, list) {
		dev_dbg(g3d->dev, "(Owner: %p, Chunks: %08x)\n",
							i->owner, i->chunks);
	}
}

static void g3d_print_remaining_chunks(struct g3d_drvdata *g3d)
{
	int i;
	int free = 0;

	for(i = 0; i < g3d->chunk_num; ++i) {
		if(!g3d->chunks[i].owner) {
			dev_dbg(g3d->dev, "Free chunk: %08x\n",
						g3d->chunks[i].mem.phys);
			++free;
		}
	}

	dev_dbg(g3d->dev, "Remaining free chunks %d of %d\n",
							free, g3d->chunk_num);
}
#else /* DEBUG */
static inline void g3d_print_alloc_info(struct g3d_drvdata *g3d) {}
static inline void g3d_print_remaining_chunks(struct g3d_drvdata *g3d) {}
#endif /* DEBUG */

/* Must be called with mem_lock held */
static unsigned long g3d_available_chunk_size(struct g3d_drvdata *g3d,
				unsigned int size, struct g3d_context *ctx)
{
	unsigned int chunks;
	unsigned int mask, bits;
	int start = G3D_UI_CHUNK_NUM;
	int end = g3d->chunk_num;
	int enable_lmk = 1;
	int i;
	int retry;

	size = round_up(size, G3D_CHUNK_SIZE);
	chunks = size / G3D_CHUNK_SIZE;
	mask = (1 << chunks) - 1;

	dev_dbg(g3d->dev, "%s: looking for %d free chunk(s)\n",
							__func__, chunks);

	if (list_empty(&g3d->alloc_list)
	    || list_first_entry(&g3d->alloc_list,
	    struct g3d_alloc_info, list)->owner == ctx) {
		enable_lmk = 0;
		start = 0;
		end = G3D_UI_CHUNK_NUM;
	}

	for(retry = 0; retry < 10; ++retry) {
		DEFINE_WAIT(wait);

		bits = mask << start;
		for(i = start; i <= end - chunks; ++i) {
			if ((g3d->free_bitmap & bits) == bits) {
				if (retry)
					dev_dbg(g3d->dev,
						"%s: found memory after %d retries\n",
						__func__, retry);
				return size;
			}
			bits <<= 1;
		}

#ifdef G3D_LOW_MEMORY_KILLER
		if (enable_lmk)
			g3d_low_memory_killer(uiRequsetBlock,uiMemMask,id);
#endif

		prepare_to_wait_exclusive(&g3d->mem_wq,
						&wait, TASK_INTERRUPTIBLE);

		mutex_unlock(&g3d->mem_lock);

		schedule_timeout(msecs_to_jiffies(100));
		finish_wait(&g3d->mem_wq, &wait);

		mutex_lock(&g3d->mem_lock);
	}

	dev_err(g3d->dev,
		"%s: could not find sufficient memory block\n", __func__);

	return 0;
}

static void g3d_register_alloc_info(struct g3d_drvdata *g3d,
						int index, unsigned int cnt)
{
	struct g3d_context *ctx = g3d->chunks[index].owner;
	struct g3d_alloc_info *p;
	unsigned int mask = ((1 << cnt) - 1) << index;
	int found = 0;

	list_for_each_entry(p, &g3d->alloc_list, list) {
		if(p->owner == ctx) {
			found = 1;
			break;
		}
	}

	if (found) {
		if (p->chunks & mask) {
			dev_err(g3d->dev,
				"%s: chunks already registered\n", __func__);
			return;
		}

		p->chunks |= mask;
		return;
	}

	p = kzalloc(sizeof(struct g3d_alloc_info), GFP_KERNEL);
	if (!p) {
		dev_err(g3d->dev,
			"%s: failed to allocate alloc info\n", __func__);
		return;
	}

	p->owner	= ctx;
	p->chunks	= mask;
	list_add_tail(&p->list, &g3d->alloc_list);
}

/* Must be called with mem_lock held. */
static unsigned long g3d_reserve_chunk(struct g3d_drvdata *g3d,
				struct g3d_context *ctx, unsigned int size)
{
	unsigned int chunks = size / G3D_CHUNK_SIZE;
	unsigned int mask = (1 << chunks) - 1;
	unsigned int i, j;
	int start = G3D_UI_CHUNK_NUM;
	int end = g3d->chunk_num;

	if (list_empty(&g3d->alloc_list)
	    || list_first_entry(&g3d->alloc_list,
	    struct g3d_alloc_info, list)->owner == ctx) {
		start = 0;
		end = G3D_UI_CHUNK_NUM;
	}

	mask <<= start;
	for (i = start; i <= end - chunks; ++i) {
		if ((g3d->free_bitmap & mask) == mask)
			break;
		mask <<= 1;
	}

	if (i > end - chunks) {
		dev_err(g3d->dev,
			"%s: failed to find enough free memory\n", __func__);
		return 0;
	}

	for(j = i; j < i + chunks; ++j)
		g3d->chunks[j].owner = ctx;

	g3d->free_bitmap &= ~mask;
	g3d_register_alloc_info(g3d, i, chunks);

	g3d_print_alloc_info(g3d);
	g3d_print_remaining_chunks(g3d);

	return g3d->chunks[i].mem.phys;
}

/* Must be called with mem_lock held. */
static void g3d_unregister_alloc_info(struct g3d_drvdata *g3d,
						int index, unsigned int cnt)
{
	struct g3d_context *ctx = g3d->chunks[index].owner;
	struct g3d_alloc_info *p;
	unsigned int mask = ((1 << cnt) - 1) << index;
	int found = 0;

	list_for_each_entry(p, &g3d->alloc_list, list) {
		if(p->owner == ctx) {
			found = 1;
			break;
		}
	}

	if (!found) {
		dev_err(g3d->dev, "%s, chunk %d is not registered\n",
							__func__, index);
		return;
	}

	if(p->chunks == mask) {
		list_del(&p->list);
		kfree(p);
		return;
	}

	if((p->chunks & mask) != mask) {
		dev_err(g3d->dev, "%s: chunks already unregistered\n", __func__);
		return;
	}

	p->chunks &= ~mask;
}

/* Must be called with mem_lock held. */
static void g3d_release_chunk(struct g3d_drvdata *g3d, struct g3d_mem_blk *mem)
{
	unsigned int chunks;
	unsigned int mask;
	unsigned int c;
	int i;

	chunks = round_up(mem->size, G3D_CHUNK_SIZE) / G3D_CHUNK_SIZE;

	c = (mem->phys - g3d->gmem->start) / G3D_CHUNK_SIZE;
	if (c >= g3d->chunk_num) {
		dev_err(g3d->dev, "%s: tried to free unknown block at %08x\n",
							__func__, mem->phys);
		return;
	}
	mask = ((1 << chunks) - 1) << c;
	
	if (g3d->free_bitmap & mask) {
		dev_err(g3d->dev, "%s: chunks already freed\n", __func__);
		return;
	}

	do_munmap(current->mm,
			(unsigned long)g3d->chunks[c].mem.virt, mem->size);
	g3d->free_bitmap |= mask;
	g3d_unregister_alloc_info(g3d, c, chunks);

	g3d_print_alloc_info(g3d);

	for (i = c; i < c + chunks; ++i)
		g3d->chunks[i].owner = 0;

	g3d_print_remaining_chunks(g3d);
}

#ifdef G3D_LOW_MEMORY_KILLER
/* Must be called with mem_lock held. */
static void g3d_low_memory_killer(struct g3d_drvdata *g3d,
		unsigned int chunks, unsigned int mask, struct g3d_context *ctx)
{
	struct g3d_alloc_info *p = 0;
	unsigned int kill_id;
	int i;
	u32 bits;

	if (list_empty(&g3d->alloc_list))
		goto error;

	/* Skip the first entry */
	p = list_first_entry(&g3d->alloc_list, struct g3d_alloc_info, list);

	list_for_each_entry_continue(p, &g3d->alloc_list, list) {
		bits = mask;
		for(i = G3D_UI_CHUNK_NUM; i <= g3d->chunk_num - chunks; ++i) {
			if (p->chunks & bits == bits)
				goto found;

			bits <<= 1;
		}
	}

error:
	p = 0;

found:
	if (!p || p->owner == ctx) {
		dev_err(g3d->dev, "%s: no process could be killed\n", __func__);
		return;
	}

	for(i = G3D_UI_CHUNK_NUM; i < g3d->chunk_num; ++i) {
		if (g3d->chunks[i].owner != p->owner)
			continue;

		if (!g3d->chunks[i].owner)
			continue;

		g3d_release_chunk(g3d, &g3d->chunks[i].mem);
	}
}
#endif

static void g3d_garbage_collect(struct g3d_drvdata *g3d,
						struct g3d_context *owner)
{
	int i;

	dev_dbg(g3d->dev, "%s\n", __func__);

	mutex_lock(&g3d->mem_lock);

	for(i = 0; i < g3d->chunk_num; ++i) {
		if (g3d->chunks[i].owner != owner)
			continue;

		if (!g3d->chunks[i].owner)
			continue;

		g3d_release_chunk(g3d, &g3d->chunks[i].mem);
	}

	wake_up(&g3d->mem_wq);

	mutex_unlock(&g3d->mem_lock);
}

/*
 * Character device
 */
static inline int ctx_has_lock(struct g3d_context *ctx)
{
	struct g3d_drvdata *data = ctx->data;

	return mutex_is_locked(&data->hw_lock) && (data->hw_owner == ctx);
}

static int g3d_open(struct inode *inode, struct file *file)
{
	struct miscdevice *mdev = file->private_data;
	struct g3d_drvdata *g3d = container_of(mdev, struct g3d_drvdata, mdev);
	struct g3d_context *ctx;

	ctx = kzalloc(sizeof(struct g3d_context), GFP_KERNEL);
	ctx->data = g3d;
	ctx->file = file;
	file->private_data = ctx;

	return 0;
}

static int g3d_release(struct inode *inode, struct file *file)
{
	struct g3d_context *ctx = file->private_data;
	struct g3d_drvdata *g3d = ctx->data;

	mutex_lock(&g3d->ctl_lock);

	if (ctx_has_lock(ctx))
		mutex_unlock(&g3d->hw_lock);

	pm_runtime_mark_last_busy(g3d->dev);
	while (ctx->power_requested--)
		pm_runtime_put_autosuspend(g3d->dev);

	mutex_unlock(&g3d->ctl_lock);

	g3d_garbage_collect(g3d, ctx);
	kfree(ctx);

	dev_dbg(g3d->dev, "device released\n");

	return 0;
}

static int g3d_wait_for_flush(struct g3d_context *ctx, u32 mask)
{
	struct g3d_drvdata *g3d = ctx->data;
	u32 val;
	int ret;

	val = g3d_read(g3d, FGGB_PIPESTATE);
	if ((val & mask) == 0)
		return 0;

	g3d_write(g3d, 0x0001171f, FGGB_PIPEMASK);
	g3d_write(g3d, 1, FGGB_INTMASK);

	ret = wait_event_interruptible_timeout(g3d->waitq,
			(g3d_read(g3d, FGGB_PIPESTATE) & mask) == 0, 1*HZ);
	if (!ret) {
		dev_err(g3d->dev, "wait_for_flush timed out.\n");
		g3d_soft_reset(g3d);
		ret = -EFAULT;
	}
	if (ret > 0)
		ret = 0;

	g3d_write(g3d, 0, FGGB_INTMASK);

	return ret;
}

static int g3d_mem_alloc(struct g3d_context *ctx, struct g3d_mem_blk *mem)
{
	struct g3d_drvdata *g3d = ctx->data;
	int ret = 0;
	unsigned long virt;

	mutex_lock(&g3d->mem_lock);

	mem->size = g3d_available_chunk_size(g3d, mem->size, ctx);
	if (!mem->size) {
		dev_err(g3d->dev,
			"%s: not enough memory to fulfill the allocation\n",
			__func__);
		ret = -EFAULT;
		goto finish;
	}

	mem->phys = g3d_reserve_chunk(g3d, ctx, mem->size);
	if (!mem->phys) {
		dev_err(g3d->dev, "%s: failed to reserve memory block\n",
								__func__);
		ret = -EFAULT;
		goto finish;
	}

	ctx->mmap_addr = mem->phys;
	virt = do_mmap(ctx->file, 0, mem->size,
				PROT_READ|PROT_WRITE, MAP_SHARED, 0);
	ctx->mmap_addr = 0;
	if(virt == -EINVAL) {
		dev_err(g3d->dev, "%s: failed to map memory\n", __func__);
		ret = -EFAULT;
		goto finish;
	}
	mem->virt = (void __user *)virt;

	dev_dbg(g3d->dev, "allocated %d bytes in %08x@%08lx\n",
						mem->size, mem->phys, virt);

finish:
	mutex_unlock(&g3d->mem_lock);

	return ret;
}

static int g3d_mem_free(struct g3d_context *ctx, struct g3d_mem_blk *mem)
{
	struct g3d_drvdata *g3d = ctx->data;

	mutex_lock(&g3d->mem_lock);

	dev_dbg(g3d->dev, "freeing %d in %08x@%p\n",
					mem->size, mem->phys, mem->virt);

	g3d_release_chunk(g3d, mem);
	mem->size = 0;

	wake_up(&g3d->mem_wq);

	mutex_unlock(&g3d->mem_lock);

	return 0;
}

static int g3d_unlock(struct g3d_context *ctx)
{
	struct g3d_drvdata *g3d = ctx->data;
	int ret = 0;

	mutex_lock(&g3d->ctl_lock);

	if (unlikely(!ctx_has_lock(ctx))) {
		dev_err(g3d->dev, "called S3C_G3D_UNLOCK without holding the hardware lock\n");
		ret = -EPERM;
		goto exit;
	}

	mutex_unlock(&g3d->hw_lock);
	g3d->hw_owner = 0;
#ifdef DEBUG_HWLOCK
	dev_dbg(g3d->dev, "hardware lock released by %p\n", ctx);
#endif
exit:
	mutex_unlock(&g3d->ctl_lock);

	return ret;
}

static int g3d_lock(struct g3d_context *ctx)
{
	struct g3d_drvdata *g3d = ctx->data;

	mutex_lock(&g3d->hw_lock);

	mutex_lock(&g3d->ctl_lock);
	g3d->hw_owner = ctx;
#ifdef DEBUG_HWLOCK
	dev_dbg(g3d->dev, "hardware lock acquired by %p\n", ctx);
#endif
	mutex_unlock(&g3d->ctl_lock);

	return 0;
}

static int g3d_mem_alloc_share(struct g3d_context *ctx, struct g3d_mem_blk *mem)
{
	struct g3d_drvdata *g3d = ctx->data;
	unsigned long virt;
	int ret = 0;

	mutex_lock(&g3d->mem_lock);

	ctx->mmap_addr = mem->phys;
	virt = do_mmap(ctx->file, 0, mem->size,
				PROT_READ|PROT_WRITE, MAP_SHARED, 0);
	ctx->mmap_addr = 0;
	if(virt == -EINVAL) {
		dev_err(g3d->dev, "%s: failed to map memory\n", __func__);
		ret = -EFAULT;
		goto finish;;
	}
	mem->virt = (void __user *)virt;

	dev_dbg(g3d->dev, "mapped %d bytes in %08x@%08lx\n",
						mem->size, mem->phys, virt);

finish:
	mutex_unlock(&g3d->mem_lock);

	return ret;
}

static int g3d_mem_free_share(struct g3d_context *ctx, struct g3d_mem_blk *mem)
{
	struct g3d_drvdata *g3d = ctx->data;
	int ret = 0;

	mutex_lock(&g3d->mem_lock);

	dev_dbg(g3d->dev, "unmapping %d bytes in %08x@%p\n",
					mem->size, mem->phys, mem->virt);

	if (do_munmap(current->mm, (unsigned long)mem->virt, mem->size) < 0) {
		dev_err(g3d->dev, "%s: failed to unmap memory\n", __func__);
		ret = -EFAULT;
		goto finish;
	}
	mem->virt = 0;

finish:
	mutex_unlock(&g3d->mem_lock);

	return ret;
}

static int g3d_critical_section(struct g3d_context *ctx, struct g3d_power *pwr)
{
	struct g3d_drvdata *g3d = ctx->data;
	int ret = 0;

	mutex_lock(&g3d->ctl_lock);

	if (pwr->request) {
		++ctx->power_requested;
		ret = pm_runtime_get_sync(g3d->dev);
		if (ret >= 0)
			ret = 0;
		goto finish;
	}

	--ctx->power_requested;
	pm_runtime_mark_last_busy(g3d->dev);
	pm_runtime_put_autosuspend(g3d->dev);

finish:
	mutex_unlock(&g3d->ctl_lock);

	return ret;
}

static long g3d_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	struct g3d_context *ctx = file->private_data;
	struct g3d_drvdata *g3d = ctx->data;
	int ret = 0;

	switch (cmd) {
	case S3C_3D_GET_CONFIG: {
		struct g3d_config cfg = {
			.sfr_base = g3d->mem->start,
			.sfr_size = resource_size(g3d->mem),
			.single_pipeline = 1,
			.dma_available = 0,
			.dma_base = 0,
			.dma_size = 0
		};
		ret = copy_to_user((void __user *)arg, &cfg,
						sizeof(struct g3d_config));
		if (ret) {
			dev_err(g3d->dev, "copy_to_user failed in S3C_3D_GET_CONFIG\n");
			ret = -EFAULT;
		}
		break;
	}

	case S3C_3D_CACHE_INVALID: {
		struct g3d_mem_blk mem;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_CACHE_INVALID\n");
			ret = -EFAULT;
			break;
		}
		dmac_map_area(mem.virt, mem.size, DMA_FROM_DEVICE);
		break;
	}

	case S3C_3D_CACHE_CLEAN: {
		struct g3d_mem_blk mem;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_CACHE_CLEAN\n");
			ret = -EFAULT;
			break;
		}
		dmac_map_area(mem.virt, mem.size, DMA_TO_DEVICE);
		break;
	}

	case S3C_3D_CACHE_CLEAN_INVALID: {
		struct g3d_mem_blk mem;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_CACHE_CLEAN_INVALID\n");
			ret = -EFAULT;
			break;
		}
		dmac_map_area(mem.virt, mem.size, DMA_BIDIRECTIONAL);
		break;
	}

	case S3C_3D_POWER_INIT:
		break;

	case S3C_3D_WAIT_FOR_FLUSH:
		ret = g3d_wait_for_flush(ctx, arg);
		break;

	case S3C_3D_MEM_ALLOC: {
		struct g3d_mem_blk mem;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_MEM_ALLOC\n");
			ret = -EFAULT;
			break;
		}
		ret = g3d_mem_alloc(ctx, &mem);
		if (ret)
			break;
		ret = copy_to_user((void __user *)arg, &mem,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_to_user failed in S3C_3D_MEM_ALLOC\n");
			ret = -EFAULT;
		}
		break;
	}

	case S3C_3D_MEM_FREE: {
		struct g3d_mem_blk mem;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_MEM_FREE\n");
			ret = -EFAULT;
			break;
		}
		ret = g3d_mem_free(ctx, &mem);
		if (ret)
			break;
		ret = copy_to_user((void __user *)arg, &mem,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_to_user failed in S3C_3D_MEM_FREE\n");
			ret = -EFAULT;
		}
		break;
	}

	case S3C_3D_MEM_ALLOC_SHARE: {
		struct g3d_mem_blk mem;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_MEM_ALLOC_SHARE\n");
			ret = -EFAULT;
			break;
		}
		ret = g3d_mem_alloc_share(ctx, &mem);
		if (ret)
			break;
		ret = copy_to_user((void __user *)arg, &mem,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_to_user failed in S3C_3D_MEM_ALLOC_SHARE\n");
			ret = -EFAULT;
		}
		break;
	}

	case S3C_3D_MEM_SHARE_FREE: {
		struct g3d_mem_blk mem;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_MEM_SHARE_FREE\n");
			ret = -EFAULT;
			break;
		}
		ret = g3d_mem_free_share(ctx, &mem);
		if (ret)
			break;
		ret = copy_to_user((void __user *)arg, &mem,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_to_user failed in S3C_3D_MEM_SHARE_FREE\n");
			ret = -EFAULT;
		}
		break;
	}

	case S3C_3D_SFR_LOCK:
		ret = g3d_lock(ctx);
		break;

	case S3C_3D_SFR_UNLOCK:
		ret = g3d_unlock(ctx);
		break;

	case S3C_3D_CRITICAL_SECTION: {
		struct g3d_power pwr;
		ret = copy_from_user(&pwr, (void __user *)arg,
						sizeof(struct g3d_power));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_CRITICAL_SECTION\n");
			ret = -EFAULT;
			break;
		}
		ret = g3d_critical_section(ctx, &pwr);
		if (ret)
			break;
		ret = copy_to_user((void __user *)arg, &pwr,
						sizeof(struct g3d_power));
		if (ret) {
			dev_err(g3d->dev, "copy_to_user failed in S3C_3D_CRITICAL_SECTION\n");
			ret = -EFAULT;
		}
		break;
	}

	case S3C_3D_MAP_FIMG_SFR_ADDR: {
		struct g3d_mem_blk mem;
		unsigned long addr;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_MAP_FIMG_SFR_ADDR\n");
			ret = -EFAULT;
			break;
		}
		addr = do_mmap(file, 0, mem.size, PROT_READ|PROT_WRITE, MAP_SHARED, mem.phys);
		if (addr == -EINVAL) {
			ret = -EFAULT;
			break;
		}
		mem.virt = (void __user *)addr;
		ret = copy_to_user((void __user *)arg, &mem,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_to_user failed in S3C_3D_MAP_FIMG_SFR_ADDR\n");
			ret = -EFAULT;
		}
		break;
	}

	case S3C_3D_UNMAP_FIMG_SFR_ADDR: {
		struct g3d_mem_blk mem;
		ret = copy_from_user(&mem, (void __user *)arg,
						sizeof(struct g3d_mem_blk));
		if (ret) {
			dev_err(g3d->dev, "copy_from_user failed in S3C_3D_UNMAP_FIMG_SFR_ADDR\n");
			ret = -EFAULT;
			break;
		}
		do_munmap(current->mm, (unsigned long)mem.virt, mem.size);
		break;
	}

	default:
		dev_dbg(g3d->dev, "invalid IOCTL %08x.\n", cmd);
		//return -EINVAL;
	}

	return ret;
}

static int g3d_mmap(struct file* filp, struct vm_area_struct *vma)
{
	struct g3d_context *ctx = filp->private_data;
	struct g3d_drvdata *g3d = ctx->data;
	unsigned long phys;
	unsigned long size;
	unsigned long pfn;

	phys = ctx->mmap_addr;
	size = vma->vm_end - vma->vm_start;

	if (!phys) {
		if(size > resource_size(g3d->mem)) {
			dev_err(g3d->dev, "mmap size bigger than G3D SFR block\n");
			return -EINVAL;
		}

		if ((vma->vm_flags & VM_WRITE)
		    && !(vma->vm_flags & VM_SHARED)) {
			dev_err(g3d->dev, "mmap of G3D SFR block must be shared\n");
			return -EINVAL;
		}

		phys = g3d->mem->start;
		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
	}

	dev_dbg(g3d->dev, "%s: mapping %lu bytes at %08lx to %08lx\n",
					__func__, size, phys, vma->vm_start);

	pfn = __phys_to_pfn(phys);

	if (remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot)) {
		dev_err(g3d->dev, "%s: remap_pfn_range failed\n", __func__);
		return -EINVAL;
	}

	return 0;
}

static struct file_operations g3d_fops = {
	.owner 		= THIS_MODULE,
	.unlocked_ioctl	= g3d_ioctl,
	.open		= g3d_open,
	.release	= g3d_release,
	.mmap		= g3d_mmap,
};

/*
 * Platform driver
 */
static int g3d_prepare_memory(struct g3d_drvdata *g3d,
						struct platform_device *pdev)
{
	struct resource *res;
	int chunk_num;
	int i;
	u32 addr;
	int ret;

	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
	if (res == NULL) {
		dev_err(&pdev->dev, "no graphics memory resource provided.\n");
		return -ENOMEM;
	}

	g3d->gmem = request_mem_region(res->start,
						resource_size(res), pdev->name);
	if (g3d->gmem == NULL) {
		dev_err(&pdev->dev, "failed to reserve graphics memory region.\n");
		return -EBUSY;
	}

	chunk_num = resource_size(g3d->gmem) / G3D_CHUNK_SIZE;
	if (chunk_num < G3D_UI_CHUNK_NUM) {
		dev_err(&pdev->dev, "graphics memory too small.\n");
		ret = -ENOMEM;
		goto err;
	}

	g3d->chunks = kzalloc(chunk_num * sizeof(struct g3d_chunk),
								GFP_KERNEL);
	if (g3d->chunks == NULL) {
		dev_err(&pdev->dev, "failed to allocate memory allocator data.\n");
		ret = -ENOMEM;
		goto err;
	}

	dev_dbg(&pdev->dev, "Reserved %d MB of memory in %d chunks of %d MB.\n",
					resource_size(g3d->gmem) / SZ_1M,
					chunk_num, G3D_CHUNK_SIZE / SZ_1M);

	addr = g3d->gmem->start;
	for (i = 0; i < chunk_num; ++i ) {
		g3d->chunks[i].mem.phys = addr;
		g3d->chunks[i].mem.size = G3D_CHUNK_SIZE;
		addr += G3D_CHUNK_SIZE;
	}

	g3d->chunk_num = chunk_num;
	g3d->free_bitmap = (1 << chunk_num) - 1;

	return 0;

err:
	release_resource(g3d->gmem);

	return ret;
}

static void g3d_free_memory(struct g3d_drvdata *g3d)
{
	kfree(g3d->chunks);
	release_resource(g3d->gmem);
}

static int __init g3d_probe(struct platform_device *pdev)
{
	struct g3d_drvdata *g3d;
	struct resource *res;
	int ret;
	u32 version;

	dev_dbg(&pdev->dev, "s3c_g3d probe(id=%d) called\n", pdev->id);

	if (pdev->id != -1) {
		dev_err(&pdev->dev, "only single instance is allowed.\n");
		return -EINVAL;
	}

	g3d = kzalloc(sizeof(struct g3d_drvdata), GFP_KERNEL);
	if(g3d == NULL) {
		dev_err(&pdev->dev, "failed to allocate driver data.\n");
		return -ENOMEM;
	}

	/* initialize the miscdevice struct */
	g3d->mdev.minor	= MISC_DYNAMIC_MINOR;
	g3d->mdev.name	= "s3c-g3d";
	g3d->mdev.fops	= &g3d_fops;

	/* get device clock */
	g3d->clock = clk_get(&pdev->dev, "3dse");
	if (g3d->clock == NULL) {
		dev_err(&pdev->dev, "failed to find g3d clock source\n");
		ret = -ENOENT;
		goto err_clock;
	}
	clk_enable(g3d->clock);

	pm_runtime_set_autosuspend_delay(&pdev->dev, G3D_AUTOSUSPEND_DELAY);
	pm_runtime_use_autosuspend(&pdev->dev);
	pm_runtime_enable(&pdev->dev);

	/* get the memory region for the post processor driver */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if(res == NULL) {
		dev_err(&pdev->dev, "failed to get memory region resource.\n");
		ret = -ENOENT;
		goto err_mem;
	}

	/* reserve the memory */
	g3d->mem = request_mem_region(res->start, resource_size(res),
								pdev->name);
	if (g3d->mem == NULL) {
		dev_err(&pdev->dev, "failed to reserve memory region\n");
		ret = -ENOENT;
		goto err_mem;
	}

	/* map the memory */
	g3d->base = ioremap(g3d->mem->start, resource_size(g3d->mem));
	if (g3d->base == NULL) {
		dev_err(&pdev->dev, "ioremap failed\n");
		ret = -ENOENT;
		goto err_ioremap;
	}

	ret = g3d_prepare_memory(g3d, pdev);
	if (ret) {
		dev_err(&pdev->dev, "could not prepare graphics memory.\n");
		goto err_prepare;
	}

	/* get the IRQ */
	g3d->irq = platform_get_irq(pdev, 0);
	if (g3d->irq <= 0) {
		dev_err(&pdev->dev,
			"failed to get irq resource (%d).\n", g3d->irq);
		ret = g3d->irq;
		goto err_irq;
	}

	g3d->dev = &pdev->dev;
	g3d->hw_owner = NULL;
	mutex_init(&g3d->ctl_lock);
	mutex_init(&g3d->mem_lock);
	mutex_init(&g3d->hw_lock);
	init_waitqueue_head(&g3d->waitq);
	init_waitqueue_head(&g3d->mem_wq);
	INIT_LIST_HEAD(&g3d->alloc_list);

	platform_set_drvdata(pdev, g3d);

	pm_runtime_get_sync(&pdev->dev);

	g3d_soft_reset(g3d);

	version = g3d_read(g3d, FGGB_VERSION);
	dev_info(&pdev->dev, "detected FIMG-3DSE version %d.%d.%d\n",
		version >> 24, (version >> 16) & 0xff, (version >> 8) & 0xff);

	/* request the IRQ */
	ret = request_irq(g3d->irq, g3d_isr, 0, pdev->name, g3d);
	if (ret) {
		dev_err(&pdev->dev, "request_irq failed (%d).\n", ret);
		goto err_irq;
	}

	ret = misc_register(&g3d->mdev);
	if (ret < 0) {
		dev_err(&pdev->dev, "could not register miscdev (%d)\n", ret);
		goto err_misc_register;
	}

	pm_runtime_put_sync(&pdev->dev);

	return 0;

err_misc_register:
	free_irq(g3d->irq, pdev);
err_irq:
	pm_runtime_put_sync(&pdev->dev);
	g3d_free_memory(g3d);
err_prepare:
	iounmap(g3d->base);
err_ioremap:
	release_resource(g3d->mem);
err_mem:
	clk_disable(g3d->clock);
	clk_put(g3d->clock);
err_clock:
	kfree(g3d);

	return ret;
}

static int __devexit g3d_remove(struct platform_device *pdev)
{
	struct g3d_drvdata *g3d = platform_get_drvdata(pdev);

	misc_deregister(&g3d->mdev);

	pm_runtime_suspend(&pdev->dev);
	pm_runtime_disable(&pdev->dev);

	free_irq(g3d->irq, g3d);
	iounmap(g3d->base);
	release_resource(g3d->mem);
	clk_put(g3d->clock);

	g3d_free_memory(g3d);

	kfree(g3d);

	return 0;
}

static int g3d_runtime_suspend(struct device *dev)
{
	struct g3d_drvdata *g3d = dev_get_drvdata(dev);

	clk_disable(g3d->clock);

	return 0;
}

static int g3d_runtime_resume(struct device *dev)
{
	struct g3d_drvdata *g3d = dev_get_drvdata(dev);

	clk_enable(g3d->clock);
	g3d_soft_reset(g3d);

	return 0;
}

static int g3d_suspend(struct device *dev)
{
	struct g3d_drvdata *g3d = dev_get_drvdata(dev);

	clk_disable(g3d->clock);

	return 0;
}

static int g3d_resume(struct device *dev)
{
	struct g3d_drvdata *g3d = dev_get_drvdata(dev);

	clk_enable(g3d->clock);
	g3d_soft_reset(g3d);

	return 0;
}

static struct dev_pm_ops g3d_pm_ops = {
	.suspend		= g3d_suspend,
	.resume			= g3d_resume,
	.runtime_suspend	= g3d_runtime_suspend,
	.runtime_resume		= g3d_runtime_resume,
};

static struct platform_driver g3d_driver = {
	.remove         = g3d_remove,
	.driver		= {
		.owner	= THIS_MODULE,
		.name	= "s3c-g3d",
		.pm	= &g3d_pm_ops,
	},
};

int __init  g3d_init(void)
{
	return platform_driver_probe(&g3d_driver, g3d_probe);
}

void __exit g3d_exit(void)
{
	platform_driver_unregister(&g3d_driver);
}

module_init(g3d_init);
module_exit(g3d_exit);

MODULE_AUTHOR("Tomasz Figa <tomasz.figa at gmail.com>");
MODULE_DESCRIPTION("Samsung G3D legacy kernel driver");
MODULE_LICENSE("GPL");

